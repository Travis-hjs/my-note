<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title>ES6</title>
    </head>
    <body>
        <ul class="list">
            <li>1</li>
            <li>2</li>
            <li>3</li>
            <li>2</li>
            <li>2</li>
            <li>2</li>
            <li>2</li>
        </ul>
        <script type="text/javascript">
            // 貌似浏览器还不支持导出导入
            // var _exportTest = require('./js/export-test.js');
            // import { exportOne, exportTwo } from './js/export-test.js'
            // console.log(exportOne, exportTwo);

            // let or var
            var _functions = [];
            // ES5 可以利用闭包解决这个问题
            // for (var i = 0; i < 10; i++) {
            //     _functions.push((function(value) {
            //         return function() {
            //             console.log(value)
            //         }
            //     }(i)))
            // }
            // ES6 直接 let解决
            for (let i = 0; i < 10; i++) {
                _functions.push(function() {
                    console.log(i)
                });
            }
            _functions.forEach(function(_fn) {
    	        _fn()
    	    });


            // 1.includes：判断是否包含然后直接返回布尔值
            let str = 'hahay'
            console.log(str.includes('y')) // true
            // 2.repeat: 获取字符串重复n次
            let _text = 'he'
            console.log(_text.repeat(3)) // 'hehehe'
            //如果是小数, Math.floor(num) 来处理

            //  ES5
            function action(num) {
                num = num || 200;
                return num
            }
            //  ES6
            function action(num = 200) {
                console.log(num)
            }
            action();
            action(300);

            //  拓展的对象功能
            // function people(name, age) {
            //     return {
            //         name: name,
            //         age: age
            //     };
            // }
            //  键值对重名，ES6可以简写如下：
            function people(name, age) {
                return {
                    name,
                    age
                };
            }


            // 对象浅复制
            const objA={ name: 'hjs' }
            const objB={ age: 18 }
            const obj = Object.assign({}, objA, objB);
            // console.log(obj);


            //  解构赋值
            const personal = {
                name: '黄景圣',
                age: 18,
                info: ['hjs','178cm','64kg']
            }
            // ES5
            // var name = personal.name
            // var age = personal.age
            // ES6e
            let { name, age } = personal
            let [Egname, tall, weight] = personal.info
            // console.log(name, age, Egname, tall, weight)


            // 数组拼接 展开运算符
            const arr1 = [0, 1, 2];
            const arr2 = [3, 4, 5];
            // ES5的 写法
            // var _newArr = Array.prototype.push.apply(arr1, arr2);
            // console.log(arr1.concat(arr2), _newArr);
            // ES6 的写法
            arr1.push(...arr2);
            // console.log(arr1);
            // 或者
            // console.log([...arr1,...arr2]);


            // 同步的方式去写异步代码
            setTimeout(function() {
                console.log(1)
            }, 0);
            new Promise(function executor(resolve) {
                console.log(2);
                // 这里的意思是，如果不执行 executor 该函数时，下面所有的then()里面的函数都不会执行
                for( let i = 0 ; i < 10000 ; i++ ) {
                    i == 9999 && resolve();
                }
                console.log(3);
            }).then(function() {
                console.log(4);
            }).then(function () {
                console.log(6);
            });
            console.log(5);


            // 生成器
            function *createIterator() {
                yield 'one';
                yield 'two';
                yield 'three';
            }
            // 生成器能像正规函数那样被调用，但会返回一个迭代器
            let iterator = createIterator();
            // console.log(iterator.next().value,iterator.next().value); // 1, 2
            // console.log(iterator.next().value);  // 3
            //taskDef即一个生成器函数
            function run(taskDef) {
                // 创建迭代器，让它在别处可用
                let task = taskDef();
                // 启动任务
                let result = task.next();
                // 递归使用函数来保持对 next() 的调用
                function step() {
                    // 如果还有更多要做的
                    console.log(result);
                    if (!result.done) {
                        result = task.next();
                        step();
                    }
                }
                // 开始处理过程
                step();
            }
            // run(createIterator)


            //  set 和 for..of
            const setArr = new Set();
            [2, 3, 5, 4, 5, 2, 2].forEach(x => setArr.add(x));
            for (let i of setArr) {
                console.log(`set: ${ i }`);
            }
            const typeArr = ['type-1', 'type-2', { type: 'type-3' }];
            for(let index in typeArr){
                console.log(`for-in: ${typeArr[index]}, index: ${ index }, obj: ${ typeArr }`);
            }

            var _obj = new Proxy({}, {
                get: function (target, key, receiver) {
                    console.log(`getting ${key}!`);
                    return Reflect.get(target, key, receiver);
                },
                set: function (target, key, value, receiver) {
                    console.log(`setting ${key}!`);
                    return Reflect.set(target, key, value, receiver);
                }
            });



        </script>
    </body>
</html>
